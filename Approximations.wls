#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Input:: *)
(*(* Some boring setup things. *)*)
(*SetDirectory[NotebookDirectory[]];*)
(*Colours=Lookup["DefaultPlotStyle"]@Lookup[Method]@Charting`ResolvePlotTheme[Automatic,Plot];*)
(**)
(*AbsErr[Data_,Real_]:=Data-Real;*)
(*RelErr[Data_,Real_]:=(Data-Real)/Real;*)
(**)
(*AtomDist=ProbabilityDistribution[{"CDF", UnitStep[\[FormalX]]}, {\[FormalX],-\[Infinity],\[Infinity]}];*)
(**)
(*(* Convert a defective PDF to a full PDF by adding an atom at 0. *)*)
(*CompletePDF[g_,p0_]:=Function[\[FormalX],p0*PDF[AtomDist,\[FormalX]]+g[\[FormalX]]];*)
(**)
(*(**)
(*  Approximate the random sum X = \!\( *)
(*\*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(N\)]\( *)
(*\*SubscriptBox[\(U\), \(k\)]\ by\ a\ mixture\ distribution . \ We\ truncate\ N\ to\ \((0, NMax)\)\ so\ that\ Pr\((N\  \[LessEqual] \ NMax)\)\)\) \[GreaterEqual] 0.999. The resulting distribution normally allows for easy simulation (maybe a little slow if NMax is huge),CDF calculation (if Subscript[U, 1]+Subscript[U, 2] has a simple distribution), but has no PDF evaluation.*)
(**)*)
(*CompoundDistribution[NDist_,UDist_,NMin_:1,NMax_:\[Infinity],IncludeZero_:True]:=Module[{Components,Weights,Cutoff=1-E^-5,NumComps},*)
(*NumComps=If[NumericQ[InverseCDF[NDist,0.999]],Min[Ceiling[InverseCDF[NDist, 0.999]],NMax],NMax];*)
(*NumComps=Max[NumComps,NMin];*)
(**)
(*Print["Using ", NumComps , " non-degenerate components in the mixture."];*)
(*Weights=PDF[NDist, Range[If[IncludeZero,0,1],NumComps]];*)
(*Components=Map[TransformedDistribution[Sum[Subscript[\[FormalCapitalX], i],{i,#}],Table[Subscript[\[FormalCapitalX], i] \[Distributed]UDist,{i,#}]]&,Range[NumComps]];*)
(*If[IncludeZero,PrependTo[Components,AtomDist]];*)
(*Return[MixtureDistribution[Weights,Components]];*)
(*];*)
(**)
(*(* Sample R iid replicates of X = \!\( *)
(*\*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(N\)]\( *)
(*\*SubscriptBox[\(U\), \(k\)] . \ This\ will\ be\ \(\(slow\)\(.\)\)\)\) *)*)
(*RandomCompoundSum[NDist_,UDist_,R_]:=Module[{Ns},*)
(*Ns=RandomVariate[NDist,R];*)
(*Table[Total[RandomVariate[UDist,Ns[[i]]]],{i,R}]*)
(*];*)
(**)
(*ReferenceCMC[NDist_,UDist_,xs_,as_,R_:10]:=Module[{Ss,CrudeDist,SLP,Verbose=R>10^6},*)
(*If[Verbose,Print["Starting simulating..."]];*)
(*Ss=RandomCompoundSum[NDist,UDist,R];*)
(*If[Verbose,Print["Constructing distribution..."]];*)
(*CrudeDist=EmpiricalDistribution[Ss];*)
(*If[Verbose,Print["Finding SLP function..."]];*)
(*SLP[\[FormalA]_]=Mean@Table[Max[Ss[[i]]-\[FormalA],0],{i,R}];*)
(*If[Verbose,Print["Calculating over the grid..."]];*)
(*{SurvivalFunction[CrudeDist,xs],SLP /@ as}*)
(*];*)
(**)
(*(* Renaming commonly used attributed of the gamma distribution & function. *)*)
(*\[CapitalGamma]=Gamma;*)
(*\[Gamma][r_,m_,x_]:=PDF[GammaDistribution[r,m],x];*)
(*\[CapitalGamma]l[r_,m_,x_]:=CDF[GammaDistribution[r,m],x];*)
(*\[CapitalGamma]u[r_,m_,x_]:=SurvivalFunction[GammaDistribution[r,m],x];*)
(**)
(*(* Create the list {Subscript[Overscript[q, ~], 1,k],...,Subscript[Overscript[q, ~], k,k]} using Lemma 1 of our paper. *)*)
(*qTildes[r_,k_]:=Sqrt[\[CapitalGamma][k+r]/(\[CapitalGamma][r]\[CapitalGamma][k+1])]Table[(-1)^(k+i) Binomial[k,i]  ,{i,0,k}];*)
(**)
(*(* The Subscript[c, k] coefficients from (38) in our paper. *)*)
(*cCoeff[r_,k_]:=Sqrt[\[CapitalGamma][k+r]/(\[CapitalGamma][k+1]\[CapitalGamma][r])]*)
(**)
(*PGF[NDist_,s_]:=MomentGeneratingFunction[NDist,Log[s]];*)
(**)
(*(* Find the Subscript[q, k] coefficients for the orthogonal Gamma expansion of X = \!\( *)
(*\*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(N\)]\( *)
(*\*SubscriptBox[\(U\), \(k\)]\(.\)\)\) *)*)
(*OrthoGammaCoeffs[NDist_,UDist_,r_,m_,K_,Verbosity_:1,LTofU_:None,Tilt_:0]:=Module[{Coeffs,LTofSN,LT,CGF,TaylorCGF,c},*)
(*If[Verbosity>= 3,Print["Starting OrthoGammaCoeffs..." ]];*)
(**)
(*(* Laplace transforms of Subscript[f, S_N] and e^(-Tilt x) (Subscript[f, S_N]^+). *)*)
(*LTofSN[\[FormalT]_]=PGF[NDist,If[LTofU=!= None,LTofU[\[FormalT]],MomentGeneratingFunction[UDist,-\[FormalT]]]];*)
(*LT[\[FormalT]_]=LTofSN[\[FormalT]+Tilt]-PDF[NDist,0];*)
(**)
(*If[Verbosity>= 3,Print["Lap trans of \!\(\*SuperscriptBox[\(e\), \(\(-Tilt\)\\\ x\)]\) \!\(\*SuperscriptBox[SubscriptBox[\(f\), \(X\)], \(+\)]\)", LT[\[FormalT]], " at 0 is ", LT[0]//N ]];*)
(**)
(*(*Generating Function of the coefficients of the expansion*)*)
(*CGF[\[FormalZ]_]=(1+\[FormalZ])^-r LT[-\[FormalZ]/(m (1+\[FormalZ]))];*)
(**)
(*(*To Print the coefficients or not to print the coefficients*)*)
(*If[Verbosity>= 3,Print["C[\[FormalZ]]=",CGF[\[FormalZ]]]];*)
(**)
(*(*Taylor Development arround 0 of the generating function of the coefficients*)*)
(*TaylorCGF[\[FormalZ]_]=Normal[Series[CGF[\[FormalZ]],{\[FormalZ],0,K}]];*)
(*If[Verbosity>=3 ,Print["Taylor[\[FormalZ]]=",N@TaylorCGF[\[FormalZ]]]];*)
(**)
(*(*Coefficients of the expansion*)*)
(*c= Table[cCoeff[r,k],{k,0,K}];*)
(*PadRight[CoefficientList[TaylorCGF[\[FormalZ]],\[FormalZ]],K+1]/c*)
(*]; *)
(**)
(*PseudoGammaCoeffsIndirectly[NDist_,UDist_,r_,m_,K_,Verbosity_:1,LTofU_:None,Tilt_:0]:=Module[{qs,KChop,Small,Ind,pLemma,ps,pFix},*)
(*If[Verbosity>= 3,Print["Starting PseudoGammaCoeffsIndirectly..."]];*)
(*qs=OrthoGammaCoeffs[NDist,UDist,r,m,K,Verbosity,LTofU,Tilt];*)
(**)
(*(* Chop off the q's when they start getting consistently small. *)*)
(*AbsoluteTiming[Small=Map[#<0 &,Abs@N[qs]]];*)
(*Ind=SequencePosition[Small,ConstantArray[True,8]];*)
(**)
(*KChop=If[Length[Ind]== 0,K,*)
(*qs=qs[[1;;First@First@Ind-1]];*)
(* Length[qs]-1];*)
(*If[Verbosity>= 1 && KChop<K,Print["Effective K is ", KChop, " original was ", K]];*)
(**)
(*If[Verbosity>= 1,Print["N@qs are ",N@qs]];*)
(*pLemma[\[FormalI]_]=If[r== 1,*)
(*Sum[Subscript[\[FormalQ], \[FormalK]] (-1)^(\[FormalK]+\[FormalI]) Binomial[\[FormalK],\[FormalI]],{\[FormalK],\[FormalI],KChop}],*)
(*Sum[Subscript[\[FormalQ], \[FormalK]] (-1)^(\[FormalK]+\[FormalI])/(\[FormalI]! (\[FormalK]-\[FormalI])!) Sqrt[(\[FormalK]! Gamma[\[FormalK]+r])/Gamma[r]],{\[FormalK],\[FormalI],KChop}]];*)
(*ps=Table[0,{i,0,KChop}];*)
(**)
(*For[i=0,i<= KChop,i++,*)
(*ps[[i+1]]=pLemma[i]/(1-m Tilt)^(r+i)*)
(*];*)
(**)
(*Repl=Table[Subscript[\[FormalQ], k]-> qs[[k+1]],{k,0,KChop}];*)
(**)
(*For[i=0,i<=KChop,i++,*)
(*ps[[i+1]]=ps[[i+1]]/.Repl*)
(*];*)
(**)
(*ps*)
(*]; *)
(**)
(*TransformInversion[LT_,x_,a_:18.5,M1_:10,M2_:10]:=Module[{Ss},*)
(*Ss=E^(a/2)/x Table[(-1)^k Re[LT[(a+I *2\[Pi] k)/(2 x)]],{k,0,M1+M2}];*)
(*Ss[[1]]/=2;*)
(*Ss=Accumulate[Ss];*)
(**)
(*Sum[Binomial[M1,k] 2^-M1 Ss[[M2+k+1]],{k,0,M1}]*)
(*];*)
(**)
(*LaplaceInversionMethod[NDist_,UDist_,LTofU_:None]:=Module[{LTsum,LTsumstar,LTcdf,LTsvf,cdf,svf,cdfStar,svfStar},*)
(*(* Laplace transform of Subscript[S, N] *)*)
(*LTsum[\[FormalT]_]=PGF[NDist,If[LTofU=!=None,LTofU[\[FormalT]],MomentGeneratingFunction[UDist,-\[FormalT]]]];*)
(**)
(*cdf[\[FormalX]_]:=TransformInversion[LTsum[#]/# &,\[FormalX]];*)
(*svf[\[FormalX]_]:=TransformInversion[(1-LTsum[#])/# &,\[FormalX]];*)
(**)
(*(* Laplace transform of Subscript[S, N]^*, needed for stop-loss premiums. *)*)
(*LTsumstar[\[FormalT]_]=(1-LTsum[\[FormalT]])/(\[FormalT] Mean[NDist]Mean[UDist]);*)
(**)
(*cdfStar[\[FormalX]_]:=TransformInversion[LTsumstar[#]/# &,\[FormalX]];*)
(*svfStar[\[FormalX]_]:=TransformInversion[(1-LTsumstar[#])/# &,\[FormalX]];*)
(**)
(*{cdf,svf,cdfStar,svfStar}*)
(*];*)


(* ::Subchapter:: *)
(*Test 0: Negative Binomial / Exponential.*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Problem description *)*)
(*\[Alpha]=10;p=3/4;\[Lambda]=6;*)
(**)
(*(* Accuracy parameters *)*)
(* K=\[Alpha]-1;R=10^6;numPoints=100;*)
(**)
(*(* This is the original problem, but it will soon be replaced. *)*)
(*NDist=NegativeBinomialDistribution[\[Alpha],p];*)
(*UDist=ExponentialDistribution[\[Lambda]];*)
(**)
(*(* Lemma 2 means we can instead use: *)*)
(*NDist=BinomialDistribution[\[Alpha],1-p];*)
(*UDist=ExponentialDistribution[p \[Lambda]];*)
(**)
(*(* Calculate the real distribution. *)*)
(*Print["Get the real distribution."];*)
(*RealDist=CompoundDistribution[NDist,UDist,\[Alpha],\[Alpha],True];*)
(*RealSVF[\[FormalX]_]=SurvivalFunction[RealDist,\[FormalX]];*)
(*RealSLP[\[FormalA]_]=Expectation[Max[\[FormalCapitalS]-\[FormalA],0],\[FormalCapitalS]\[Distributed]RealDist,Assumptions->\[FormalA]>0];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*r=1; m=1/(p \[Lambda]);*)
(**)
(*Print["Get the ps using the qs."]*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,m,K,2];*)
(**)
(*Print["Converting ps to machine prec."];*)
(*For[i=0,i<= K,i++,*)
(*If[Mod[i,5]== 0, Print["Converting \!\(\*SubscriptBox[\(p\), \(i\)]\) for i = ",i]];*)
(*ps[[i+1]]=N[ps[[i+1]]]*)
(*];*)
(*Print["N@ps are ", N@ps, " first is ", First@ps];*)
(*Print["Total ps are ", N@Total[ps], " and the sum is ",N@ Sum[ps[[i]],{i,Length[ps]}]];*)
(**)
(*OrthoSVF[\[FormalX]_]=Sum[ps[[i+1]] \[CapitalGamma]u[r+i,m,\[FormalX]],{i,0,K}]//Refine[#,\[FormalX]>0]&//Simplify;*)
(*OrthoSLP[\[FormalA]_]=Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,\[FormalA]]-\[FormalA] \[CapitalGamma]u[r+i,m,\[FormalA]]),{i,0,K}]//Refine[#,\[FormalA]>0]&//Simplify;*)
(**)
(*(* Make the grids to evaluate over, and some helper functions. *)*)
(*(*xMax=10*Mean[NDist]*Mean[UDist];dx=xMax/numPoints;xs=Table[i,{i,dx,xMax,dx}];*)
(*aMax=5*Mean[NDist]*Mean[UDist];da=aMax/numPoints;as=Table[i,{i,da,aMax,da}];*)*)
(*xs=Table[i/2,{i,5}];as=Table[i/2,{i,5}];*)
(**)
(*WithX[Data_]:=Transpose[{xs,Data}];*)
(*WithA[Data_]:=Transpose[{as,Data}];*)
(**)
(*(* Get the true values on these points. *)*)
(*RealSVFs=RealSVF/@xs;*)
(*RealSLPs=RealSLP/@as;*)
(**)
(*(* Orthogonal expansion on these points. *)*)
(*OrthoSVFs=OrthoSVF/@xs;*)
(*OrthoSLPs=OrthoSLP/@as;*)
(**)
(*(* Laplace inversion method. *)*)
(*{cdfI,svfI,cdfStarI,svfStarI}=LaplaceInversionMethod[NDist,UDist];*)
(**)
(*LapInvSVFs=Table[svfI[x],{x,xs}];*)
(*LapInvSLPs= Mean[NDist]Mean[UDist]Table[svfStarI[a],{a,as}];*)
(**)
(*(* Get some CMC answer. *)*)
(*(*Print["Doing CMC with R = 10^", Log10[R]];*)
(*Print["That took ", First@AbsoluteTiming[{CrudeSVFs,CrudeSLPs}= ReferenceCMC[NDist,UDist,xs,as,R];]," seconds"];*)*)
(**)
(*(***** Make the plots *****)*)
(*RefName="Real";*)
(*EstNames={"Crude MC (R = 10^" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion"};*)
(*RefSVFs=RealSVFs;RefSLPs=RealSLPs;*)
(*AllSVFs={CrudeSVFs,OrthoSVFs,LapInvSVFs};*)
(*AllSLPs={CrudeSLPs,OrthoSLPs,LapInvSLPs};*)
(**)
(*(*SVFEst=ListPlot[WithX/@Append[AllSVFs,RefSVFs],Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SVFAbsErr=ListPlot[WithX[AbsErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SVFRelErr=ListPlot[WithX[RelErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SVFPlot=Legended[GraphicsColumn[{SVFEst, SVFAbsErr,SVFRelErr}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["exponential_svf.pdf",SVFPlot];*)
(**)
(*SLPEst=ListPlot[WithA/@Append[AllSLPs,RefSLPs],Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SLPAbsErr=ListPlot[WithA[AbsErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SLPRelErr=ListPlot[WithA[RelErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)
(*SLPPlot=Legended[GraphicsColumn[{SLPEst, SLPAbsErr,SLPRelErr}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["exponential_slp.pdf",SLPPlot];*)*)


(* ::Input:: *)
(*RelErr[LapInvSVFs,RefSVFs]*)
(*RelErr[LapInvSLPs,RefSLPs]*)


(* ::Subchapter:: *)
(*Test 1: Poisson / Gamma.*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Accuracy parameters *)*)
(* K=16;R=10^6;numPoints=100;TruncOrder=250;*)
(**)
(*(* Problem description *)*)
(*\[Lambda]=2;rU=3/2;mU=1/3;*)
(*NDist=PoissonDistribution[\[Lambda]];*)
(*UDist=GammaDistribution[rU,mU];*)
(**)
(*(* Calculate an approximate distribution. *)*)
(*Print["Get the truncated distribution."];*)
(*TruncDist=CompoundDistribution[NDist,UDist,TruncOrder,TruncOrder,True];*)
(*Print["Getting truncated SVF."]*)
(*TruncSVF[\[FormalX]_]=SurvivalFunction[TruncDist,\[FormalX]];*)
(**)
(*Print["Getting truncated SLP"]*)
(*Template[\[FormalA]_]=Expectation[Max[\[FormalCapitalS]-\[FormalA],0],\[FormalCapitalS]\[Distributed]GammaDistribution[\[FormalR],\[FormalM]],Assumptions->\[FormalA]>0&&\[FormalR]>0&&\[FormalM]>0];*)
(*TruncSLP[\[FormalA]_]=Sum[PDF[NDist,n] Template[\[FormalA]]/.{\[FormalR]-> n rU,\[FormalM]-> mU},{n,1,TruncOrder-1}];*)
(*(* Orthogonal polynomial method *)*)
(*(*r=1;m=\[Lambda] Mean[UDist];*)
(*Print["m using 1-moment magic is ", N@m];*)*)
(*r=\[Lambda] Mean[UDist]^2/Moment[UDist,2];*)
(*m=Moment[UDist,2]/Mean[UDist];*)
(**)
(*Print["Get the ps using the qs."]*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,m,K];*)
(**)
(*Print["Converting ps to machine prec."];*)
(*For[i=0,i<= K,i++,*)
(*If[Mod[i,5]== 0, Print["Converting \!\(\*SubscriptBox[\(p\), \(i\)]\) for i = ",i]];*)
(*ps[[i+1]]=N[ps[[i+1]]]*)
(*];*)
(**)
(*Print["ps are ", ps];*)
(*Print["Total ps are ", Total[ps], " and the sum is ",Sum[ps[[i]],{i,Length[ps]}]];*)
(**)
(*OrthoSVF[\[FormalX]_]=Sum[ps[[i+1]] \[CapitalGamma]u[r+i,m,\[FormalX]],{i,0,K}]//Refine[#,\[FormalX]>0]&//Simplify;*)
(*OrthoSLP[\[FormalA]_]=Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,\[FormalA]]-\[FormalA] \[CapitalGamma]u[r+i,m,\[FormalA]]),{i,0,K}]//Refine[#,\[FormalA]>0]&//Simplify;*)
(**)
(*(* Make the grids to evaluate over, and some helper functions. *)*)
(*xMax=2.5*Mean[NDist]*Mean[UDist];dx=xMax/numPoints;xs=Table[i,{i,dx,xMax,dx}];*)
(*aMax=2.5*Mean[NDist]*Mean[UDist];da=aMax/numPoints;as=Table[i,{i,da,aMax,da}];*)
(**)
(*WithX[Data_]:=Transpose[{xs,Data}];*)
(*WithA[Data_]:=Transpose[{as,Data}];*)
(**)
(*(* Get the truncated values on these points. *)*)
(*TruncSVFs=TruncSVF/@xs;*)
(*TruncSLPs=TruncSLP/@as;*)
(**)
(*(* Orthogonal expansion on these points. *)*)
(*OrthoSVFs=OrthoSVF/@xs;*)
(*OrthoSLPs=OrthoSLP/@as;*)
(**)
(*(* Laplace inversion method. *)*)
(*{cdfI,svfI,cdfStarI,svfStarI}=LaplaceInversionMethod[NDist,UDist];*)
(**)
(*LapInvSVFs=Table[svfI[x],{x,xs}];*)
(*LapInvSLPs= Mean[NDist]Mean[UDist]Table[svfStarI[a],{a,as}];*)
(**)
(*(* Get some CMC answer. *)*)
(*Print["Doing CMC with R = 10^", Log10[R]];*)
(*Print["That took ", First@AbsoluteTiming[{CrudeSVFs,CrudeSLPs}= ReferenceCMC[NDist,UDist,xs,as,R];]," seconds"];*)
(**)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion","Truncated (Order = "<>ToString[TruncOrder]<>")"};*)
(*AllSVFs={CrudeSVFs, OrthoSVFs,LapInvSVFs,TruncSVFs};*)
(*AllSLPs={CrudeSLPs,OrthoSLPs,LapInvSLPs, TruncSLPs};*)
(**)
(*RefName="Median";*)
(*RefSVFs=Table[Median[AllSVFs[[;;,i]]], {i,Length[xs]}];*)
(*RefSLPs=Table[Median[AllSLPs[[;;,i]]], {i,Length[xs]}];*)
(**)
(**)
(*SVFEst=ListPlot[WithX/@Append[AllSVFs,RefSVFs],Joined->True,AspectRatio->1/3];*)
(*SVFAbsErr=ListPlot[WithX[AbsErr[#,RefSVFs]]&/@AllSVFs,Joined->True,AspectRatio->1/3];*)
(*(*SVFRelErr=ListPlot[WithX[RelErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SVFPlot=Legended[GraphicsColumn[{SVFEst, SVFAbsErr(*,SVFRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_gamma_svf.pdf",SVFPlot];*)
(**)
(*SLPEst=ListPlot[WithA/@Append[AllSLPs,RefSLPs],Joined->True,AspectRatio->1/3];*)
(*SLPAbsErr=ListPlot[WithA[AbsErr[#,RefSLPs]]&/@AllSLPs,Joined->True,AspectRatio->1/3];*)
(*(*SLPRelErr=ListPlot[WithA[RelErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SLPPlot=Legended[GraphicsColumn[{SLPEst, SLPAbsErr(*,SLPRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_gamma_slp.pdf",SLPPlot];*)
(**)


(* ::Subchapter:: *)
(*Test 2: Pascal / Gamma.*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Accuracy parameters *)*)
(* K=16;R=10^6;numPoints=100;TruncOrder=250;*)
(**)
(*(* Problem description *)*)
(*\[Alpha]=10;p=1/6;rU=3/2;mU=1/75;*)
(*NDist=NegativeBinomialDistribution[\[Alpha],p];*)
(*UDist=GammaDistribution[rU,mU];*)
(*(* Calculate an approximate distribution. *)*)
(*Print["Get the truncated distribution."];*)
(*TruncDist=CompoundDistribution[NDist,UDist,TruncOrder,TruncOrder,True];*)
(*Print["Getting truncated SVF."]*)
(*TruncSVF[\[FormalX]_]=SurvivalFunction[TruncDist,\[FormalX]];*)
(**)
(*Print["Getting truncated SLP"]*)
(*Template[\[FormalA]_]=Expectation[Max[\[FormalCapitalS]-\[FormalA],0],\[FormalCapitalS]\[Distributed]GammaDistribution[\[FormalR],\[FormalM]],Assumptions->\[FormalA]>0&&\[FormalR]>0&&\[FormalM]>0];*)
(*TruncSLP[\[FormalA]_]=Sum[PDF[NDist,n]*Template[\[FormalA]]/.{\[FormalR]-> n rU,\[FormalM]-> mU},{n,1,TruncOrder-1}];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*r=1;*)
(*radOfConv=s/.First@Solve[MomentGeneratingFunction[UDist,s]== 1/(1-p),s];*)
(*m=1/radOfConv;*)
(*Print["m using absicca magic is ", N@m];*)
(**)
(*Print["Get the ps using the qs."]*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,m,K];*)
(**)
(*Print["Converting ps to machine prec."];*)
(*For[i=0,i<= K,i++,*)
(*If[Mod[i,5]== 0, Print["Converting \!\(\*SubscriptBox[\(p\), \(i\)]\) for i = ",i]];*)
(*ps[[i+1]]=N[ps[[i+1]]]*)
(*];*)
(*Print["ps are ", ps];*)
(*Print["Total ps are ", Total[ps], " and the sum is ",Sum[ps[[i]],{i,Length[ps]}]];*)
(**)
(*OrthoSVF[\[FormalX]_]=Sum[ps[[i+1]] \[CapitalGamma]u[r+i,m,\[FormalX]],{i,0,K}]//Refine[#,\[FormalX]>0]&//Simplify;*)
(*OrthoSLP[\[FormalA]_]=Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,\[FormalA]]-\[FormalA] \[CapitalGamma]u[r+i,m,\[FormalA]]),{i,0,K}]//Refine[#,\[FormalA]>0]&//Simplify;*)
(**)
(*(* Make the grids to evaluate over, and some helper functions. *)*)
(*xMax=2.5*Mean[NDist]*Mean[UDist];dx=xMax/numPoints;xs=Table[i,{i,dx,xMax,dx}];*)
(*aMax=2.5*Mean[NDist]*Mean[UDist];da=aMax/numPoints;as=Table[i,{i,da,aMax,da}];*)
(**)
(*WithX[Data_]:=Transpose[{xs,Data}];*)
(*WithA[Data_]:=Transpose[{as,Data}];*)
(**)
(*(* Get the truncated values on these points. *)*)
(*TruncSVFs=TruncSVF/@xs;*)
(*TruncSLPs=TruncSLP/@as;*)
(**)
(*(* Orthogonal expansion on these points. *)*)
(*OrthoSVFs=OrthoSVF/@xs;*)
(*OrthoSLPs=OrthoSLP/@as;*)
(**)
(*(* Laplace inversion method. *)*)
(*{cdfI,svfI,cdfStarI,svfStarI}=LaplaceInversionMethod[NDist,UDist];*)
(**)
(*LapInvSVFs=Table[svfI[x],{x,xs}];*)
(*LapInvSLPs= Mean[NDist]Mean[UDist]Table[svfStarI[a],{a,as}];*)
(**)
(*(* Get some CMC answer. *)*)
(*Print["Doing CMC with R = 1e", Log10[R]];*)
(*Print["That took ", First@AbsoluteTiming[{CrudeSVFs,CrudeSLPs}= ReferenceCMC[NDist,UDist,xs,as,R];]," seconds"];*)


(* ::Input:: *)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion","Truncated (Order = "<>ToString[TruncOrder]<>")"};*)
(*AllSVFs={CrudeSVFs, OrthoSVFs,LapInvSVFs,TruncSVFs};*)
(*AllSLPs={CrudeSLPs,OrthoSLPs,LapInvSLPs, TruncSLPs};*)
(**)
(*RefName="Median";*)
(*RefSVFs=Table[Median[AllSVFs[[;;,i]]], {i,Length[xs]}];*)
(*RefSLPs=Table[Median[AllSLPs[[;;,i]]], {i,Length[xs]}];*)
(**)
(*SVFEst=ListPlot[WithX/@Append[AllSVFs,RefSVFs],Joined->True,AspectRatio->1/3];*)
(*SVFAbsErr=ListPlot[WithX[AbsErr[#,RefSVFs]]&/@AllSVFs,Joined->True,AspectRatio->1/3];*)
(*(*SVFRelErr=ListPlot[WithX[RelErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SVFPlot=Legended[GraphicsColumn[{SVFEst, SVFAbsErr(*,SVFRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["pascal_gamma_svf.pdf",SVFPlot];*)
(**)
(*SLPEst=ListPlot[WithA/@Append[AllSLPs,RefSLPs],Joined->True,AspectRatio->1/3];*)
(*SLPAbsErr=ListPlot[WithA[AbsErr[#,RefSLPs]]&/@AllSLPs,Joined->True,AspectRatio->1/3];*)
(*(*SLPRelErr=ListPlot[WithA[RelErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SLPPlot=Legended[GraphicsColumn[{SLPEst, SLPAbsErr(*,SLPRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["pascal_gamma_slp.pdf",SLPPlot];*)
(**)


(* ::Subchapter:: *)
(*Test 3: Poisson / Pareto.*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Accuracy parameters *)*)
(*K=16;R=10^6;numPoints=100;*)
(**)
(*(* Problem description *)*)
(*\[Lambda]=4;a=5;b=11;\[Theta]=0;*)
(**)
(*NDist=PoissonDistribution[\[Lambda]];*)
(*UDist=ParetoDistribution[a,b,\[Theta]];*)
(*LTofU[\[FormalS]_]=Expectation[E^(-\[FormalS] \[FormalCapitalX]),\[FormalCapitalX]\[Distributed]UDist];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*Tilt=1;*)
(*ThetaFracOfM=1/2;*)
(*mOrig=ThetaFracOfM/Tilt;*)
(**)
(*r=Mean[UDist];*)
(*m = mOrig/(1-mOrig Tilt);*)
(**)
(*Print["Want to take m > 1/2 Tilt i.e. ", mOrig, " > " ,1/(2 Tilt)];*)
(*Print["Tilting by ", N@Tilt, " which gives a modified m of ", N@m];*)
(**)
(*Print["Get the ps using the qs."];*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,mOrig,K,2,LTofU,Tilt];*)
(*Print["Converting ps to machine prec."];*)
(*For[i=0,i<= K,i++,*)
(*If[Mod[i,5]== 0, Print["Converting \!\(\*SubscriptBox[\(p\), \(i\)]\) for i = ",i]];*)
(*ps[[i+1]]=N[ps[[i+1]]]*)
(*];*)
(*Print["ps are ",ps];*)
(*Print["Total ps are ", Total[ps], " and the sum is ",Sum[ps[[i]],{i,Length[ps]}]];*)
(**)
(*OrthoSVF[\[FormalX]_]= Sum[ps[[i+1]] \[CapitalGamma]u[r+i,m,\[FormalX]],{i,0,K}]//Refine[#,\[FormalX]>0]&;*)
(*OrthoSLP[\[FormalA]_]= Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,\[FormalA]]-\[FormalA] \[CapitalGamma]u[r+i,m,\[FormalA]]),{i,0,K}]//Refine[#,\[FormalA]>0]&;*)
(*(* Make the grids that the Laplace inversion will evaluate on. *)*)
(*xMax=5.0*Mean[NDist]*Mean[UDist];dx=xMax/numPoints;xs=Table[i,{i,dx,xMax,dx}];*)
(*aMax=5.0*Mean[NDist]*Mean[UDist];da=aMax/numPoints;as=Table[i,{i,da,aMax,da}];*)
(**)
(*WithX[Data_]:=Transpose[{xs,Data}];*)
(*WithA[Data_]:=Transpose[{as,Data}];*)
(**)
(*(* Orthogonal expansion on these points. *) *)
(*OrthoSVFs=OrthoSVF/@xs;*)
(*OrthoSLPs=OrthoSLP/@as;*)
(**)
(*(* Laplace inversion method. *)*)
(*{cdfI,svfI,cdfStarI,svfStarI}=LaplaceInversionMethod[NDist,UDist,LTofU];*)
(**)
(*(*LapInvSVFs=Table[svfI[x],{x,xs}];*)*)
(*LapInvSVFs=Table[*)
(*svf=Quiet@Catch[svfI[x],_SystemException];*)
(*If[svf=== SystemException["MemoryAllocationFailure"],Print["Memory problem..."];svf=Indeterminate];*)
(*svf,{x,xs}];*)
(**)
(*(*LapInvSLPs= Mean[NDist]Mean[UDist]Table[svfStarI[a],{a,as}];*)*)
(*svfStars=Table[*)
(*star=Quiet@Catch[svfStarI[a],_SystemException];*)
(*If[star=== SystemException["MemoryAllocationFailure"],Print["Memory problem..."];star=Indeterminate];*)
(*star,{a,as}];*)
(*LapInvSLPs= Mean[NDist]Mean[UDist]*svfStars;*)
(**)
(*(* Get some CMC answer. *)*)
(*Print["Doing CMC with R = 10^", Log10[R]];*)
(*Print["That took ", First@AbsoluteTiming[{CrudeSVFs,CrudeSLPs}= ReferenceCMC[NDist,UDist,xs,as,R];]," seconds"];*)
(**)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion"};*)
(*AllSVFs={CrudeSVFs, OrthoSVFs,LapInvSVFs};*)
(*AllSLPs={CrudeSLPs,OrthoSLPs,LapInvSLPs};*)
(*RefName="Median";*)
(*RefSVFs=Table[Median[DeleteCases[AllSVFs[[;;,i]],Indeterminate]], {i,Length[xs]}];*)
(*RefSLPs=Table[Median[DeleteCases[AllSLPs[[;;,i]],Indeterminate]], {i,Length[xs]}];*)
(**)
(*SVFEst=ListPlot[WithX/@Append[AllSVFs,RefSVFs],Joined->True,AspectRatio->1/3];*)
(*SVFAbsErr=ListPlot[WithX[AbsErr[#,RefSVFs]]&/@AllSVFs,Joined->True,AspectRatio->1/3];*)
(*(*SVFRelErr=ListPlot[WithX[RelErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SVFPlot=Legended[GraphicsColumn[{SVFEst, SVFAbsErr(*,SVFRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_pareto_svf.pdf",SVFPlot];*)
(**)
(*SLPEst=ListPlot[WithA/@Append[AllSLPs,RefSLPs],Joined->True,AspectRatio->1/3];*)
(*SLPAbsErr=ListPlot[WithA[AbsErr[#,RefSLPs]]&/@AllSLPs,Joined->True,AspectRatio->1/3];*)
(*(*SLPRelErr=ListPlot[WithA[RelErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SLPPlot=Legended[GraphicsColumn[{SLPEst, SLPAbsErr(*,SLPRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_pareto_slp.pdf",SLPPlot];*)
(**)


(* ::Subchapter:: *)
(*Test 4: Pascal / Weibull .*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*K=16;R=10^6;numPoints=100;*)
(**)
(*(* Problem description *)*)
(*\[Alpha]=2;p=1/4;\[Beta]=1/2;\[Lambda]=1/2;*)
(*(*\[Alpha]=10;p=1/6;\[Lambda]=1/100;*)*)
(*NDist=NegativeBinomialDistribution[\[Alpha],p];*)
(*UDist=WeibullDistribution[\[Beta],\[Lambda]];*)
(*LTofU[\[FormalS]_]=Expectation[E^(-\[FormalS] \[FormalCapitalX]),\[FormalCapitalX]\[Distributed]UDist];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*Tilt=1;*)
(*ThetaFracOfM=1/2;*)
(*mOrig=ThetaFracOfM/Tilt;*)
(**)
(*r=Mean[UDist];*)
(**)
(*m = mOrig/(1-mOrig Tilt);*)
(**)
(*Print["Want to take m > 1/2 Tilt i.e. ", mOrig, " > " ,1/(2 Tilt)];*)
(*Print["Tilting by ", N@Tilt, " which gives a modified m of ", N@m];*)
(**)
(*Print["Get the ps using the qs."];*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,mOrig,K,2,LTofU,Tilt];Print["Converting ps to machine prec."];*)
(*Print[First@AbsoluteTiming[*)
(*For[i=0,i<= K,i++,*)
(*If[Mod[i,5]== 0, Print["Converting \!\(\*SubscriptBox[\(p\), \(i\)]\) for i = ",i]];*)
(*ps[[i+1]]=N[ps[[i+1]]];*)
(*];*)
(*]];*)
(**)
(*Print["ps are ", ps];*)
(*Print["Total ps are ", Total[ps], " and the sum is ",Sum[ps[[i]],{i,Length[ps]}]];*)
(**)
(*OrthoSVF[\[FormalX]_]= Sum[ps[[i+1]] \[CapitalGamma]u[r+i,m,\[FormalX]],{i,0,K}]//Refine[#,\[FormalX]>0]&;*)
(*OrthoSLP[\[FormalA]_]= Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,\[FormalA]]-\[FormalA] \[CapitalGamma]u[r+i,m,\[FormalA]]),{i,0,K}]//Refine[#,\[FormalA]>0]&;*)
(**)
(*(* Make the grids that the Laplace inversion will evaluate on. *)*)
(*xMax=5*Mean[NDist]*Mean[UDist];dx=xMax/numPoints;xs=Table[i,{i,dx,xMax,dx}];*)
(*aMax=10*Mean[NDist]*Mean[UDist];da=aMax/numPoints;as=Table[i,{i,da,aMax,da}];*)
(**)
(*WithX[Data_]:=Transpose[{xs,Data}];*)
(*WithA[Data_]:=Transpose[{as,Data}];*)
(**)
(*(* Orthogonal expansion on these points. *)*)
(*OrthoSVFs=OrthoSVF/@xs;*)
(*OrthoSLPs=OrthoSLP/@as;*)
(**)
(*(* Laplace inversion method. *)*)
(*{cdfI,svfI,cdfStarI,svfStarI}=LaplaceInversionMethod[NDist,UDist,LTofU];*)
(**)
(*LapInvSVFs=Table[svfI[x],{x,xs}];*)
(*LapInvSLPs= Mean[NDist]Mean[UDist]Table[svfStarI[a],{a,as}];*)
(**)
(*(* Get some CMC answer. *)*)
(*Print["Doing CMC with R = 10^", Log10[R]];*)
(*Print["That took ", First@AbsoluteTiming[{CrudeSVFs,CrudeSLPs}= ReferenceCMC[NDist,UDist,xs,as,R];]," seconds"];*)
(**)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion"};*)
(*AllSVFs={CrudeSVFs, OrthoSVFs,LapInvSVFs};*)
(*AllSLPs={CrudeSLPs,OrthoSLPs,LapInvSLPs};*)
(**)
(*RefName="Median";*)
(*RefSVFs=Table[Median[AllSVFs[[;;,i]]], {i,Length[xs]}];*)
(*RefSLPs=Table[Median[AllSLPs[[;;,i]]], {i,Length[xs]}];*)
(**)
(*SVFEst=ListPlot[WithX/@Append[AllSVFs,RefSVFs],Joined->True,AspectRatio->1/3];*)
(*SVFAbsErr=ListPlot[WithX[AbsErr[#,RefSVFs]]&/@AllSVFs,Joined->True,AspectRatio->1/3];*)
(*(*SVFRelErr=ListPlot[WithX[RelErr[#,RefSVFs]]&/@AllSVFs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SVFPlot=Legended[GraphicsColumn[{SVFEst, SVFAbsErr(*,SVFRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["pascal_weibull_svf.pdf",SVFPlot];*)
(**)
(*SLPEst=ListPlot[WithA/@Append[AllSLPs,RefSLPs],Joined->True,AspectRatio->1/3];*)
(*SLPAbsErr=ListPlot[WithA[AbsErr[#,RefSLPs]]&/@AllSLPs,Joined->True,AspectRatio->1/3];*)
(*(*SLPRelErr=ListPlot[WithA[RelErr[#,RefSLPs]]&/@AllSLPs,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*SLPPlot=Legended[GraphicsColumn[{SLPEst, SLPAbsErr(*,SLPRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["pascal_weibull_slp.pdf",SLPPlot];*)


(* ::Subchapter:: *)
(*Test 5: Ruin probability: Poisson / Exponential.*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Accuracy parameters *)*)
(*K=16;R=10^5;numPoints=25;*)
(**)
(*(* Problem description *)*)
(*c=1;\[Lambda]=4;UDist=ExponentialDistribution[4];UDist=GammaDistribution[2,2];*)
(**)
(*(* Time grid *)*)
(*tMax=1;*)
(*dt=tMax/numPoints;ts=Table[i,{i,dt,tMax,dt}];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*Verbosity=0;*)
(**)
(*SLPs=Table[*)
(*NDist=PoissonDistribution[\[Lambda] t];*)
(**)
(*r=\[Lambda] t Mean[UDist]^2/Moment[UDist,2];*)
(*m=Moment[UDist,2]/Mean[UDist];*)
(**)
(*SeedRandom[1];*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,m,K,Verbosity];*)
(**)
(*OrthogonalSLP= Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,c t]-c t  \[CapitalGamma]u[r+i,m,c t]),{i,0,K}];*)
(**)
(*SeedRandom[1];*)
(*CrudeSLP= First@Last@ReferenceCMC[NDist,UDist,{},{c t},R];*)
(**)
(*svfStarI=Last@LaplaceInversionMethod[NDist,UDist];*)
(*LapInvSLP= Mean[NDist]Mean[UDist]svfStarI[c t];*)
(**)
(*{OrthogonalSLP,LapInvSLP,CrudeSLP},{t,ts}];*)
(**)
(**)
(*OrthoRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,1]])//N;*)
(*LapInvRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,2]])//N;*)
(*CrudeRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,3]])//N;*)
(**)
(**)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion"};*)
(*AllRuins={CrudeRuins, OrthoRuins,LapInvRuins};*)
(**)
(*RefName="Median";*)
(*RefRuins=Table[Median[AllRuins[[;;,i]]], {i,Length[ts]}];*)
(**)
(*WithT[Data_]:=Transpose[{ts,Data}];*)
(**)
(*RuinEst=ListPlot[WithT/@Append[AllRuins,RefRuins],Joined->True,AspectRatio->1/3];*)
(*RuinAbsErr=ListPlot[WithT[AbsErr[#,RefRuins]]&/@AllRuins,Joined->True,AspectRatio->1/3];*)
(*(*RuinRelErr=ListPlot[WithA[RelErr[#,RefRuins]]&/@AllRuins,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*RuinPlot=Legended[GraphicsColumn[{RuinEst, RuinAbsErr(*,RuinRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_exponential_ruin.pdf",RuinPlot];*)


(* ::Subchapter:: *)
(*Test 6: Ruin probability: Poisson Pareto*)


(* ::Input:: *)
(*SeedRandom[1];*)


(* ::Input:: *)
(*(* Accuracy parameters *)*)
(*K=16;R=10^5;numPoints=25;*)
(**)
(*(* Problem description *)*)
(*c=1;\[Lambda]=2;a=5;b=11;\[Theta]=0;*)
(*UDist=ParetoDistribution[a,b,\[Theta]];*)
(*LTofU[\[FormalS]_]=Expectation[E^(-\[FormalS] \[FormalCapitalX]),\[FormalCapitalX]\[Distributed]UDist];*)
(**)
(*(* Time grid *)*)
(*tMax=5;*)
(*dt=tMax/numPoints;ts=Table[i,{i,10^-1,tMax,dt}];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*Verbosity=0;*)
(**)
(*SLPs=Table[*)
(*NDist=PoissonDistribution[\[Lambda] t];*)
(**)
(*(* Orthogonal polynomial method *)*)
(*Tilt=1;*)
(*ThetaFracOfM=1/2;*)
(*mOrig=ThetaFracOfM/Tilt;*)
(**)
(*r=Mean[UDist];*)
(*m = mOrig/(1-mOrig Tilt);*)
(**)
(*(*Print["Want to take m > 1/2 Tilt i.e. ", mOrig, " > " ,1/(2 Tilt)];*)
(*Print["Tilting by ", N@Tilt, " which gives a modified m of ", N@m];*)
(**)*)
(*SeedRandom[1];*)
(*ps=PseudoGammaCoeffsIndirectly[NDist,UDist,r,mOrig,K,Verbosity,LTofU,Tilt];*)
(**)
(*OrthogonalSLP= Sum[ps[[i+1]] (m(r+i)\[CapitalGamma]u[r+i+1,m,c t]-c t  \[CapitalGamma]u[r+i,m,c t]),{i,0,K}];*)
(**)
(*SeedRandom[1];*)
(*CrudeSLP=First@Last@ReferenceCMC[NDist,UDist,{},{c t},R];*)
(**)
(*svfStarI=Last@LaplaceInversionMethod[NDist,UDist,LTofU];*)
(*(*LapInvSLP= Mean[NDist]Mean[UDist]svfStarI[c t];*)*)
(**)
(*LapInvSLP=Quiet@Catch[Mean[NDist]Mean[UDist]svfStarI[c t],_SystemException];*)
(*If[LapInvSLP=== SystemException["MemoryAllocationFailure"],Print["Memory problem..."];LapInvSLP=Indeterminate];*)
(**)
(*{OrthogonalSLP,LapInvSLP,CrudeSLP},{t,ts}];*)
(**)
(*OrthoRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,1]])//N;*)
(*LapInvRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,2]])//N;*)
(*CrudeRuins=1/(c ts) (\[Lambda] ts *Mean[UDist]-SLPs[[;;,3]])//N;*)
(**)
(*(***** Make the plots *****)*)
(*EstNames={"Crude MC (R = 1e" <> ToString[Log10[R]]<>")","Orthogonal (K = "<>ToString[K]<>")","Laplace Inversion"};*)
(*AllRuins={CrudeRuins, OrthoRuins,LapInvRuins};*)
(**)
(*RefName="Median";*)
(*RefRuins=Table[Median[DeleteCases[AllRuins[[;;,i]],Indeterminate]], {i,Length[ts]}];*)
(**)
(*WithT[Data_]:=Transpose[{ts,Data}];*)
(**)
(*RuinEst=ListPlot[WithT/@Append[AllRuins,RefRuins],Joined->True,AspectRatio->1/3];*)
(*RuinAbsErr=ListPlot[WithT[AbsErr[#,RefRuins]]&/@AllRuins,Joined->True,AspectRatio->1/3];*)
(*(*RuinRelErr=ListPlot[WithA[RelErr[#,RefRuins]]&/@AllRuins,Joined\[Rule]True,AspectRatio\[Rule]1/3];*)*)
(*RuinPlot=Legended[GraphicsColumn[{RuinEst, RuinAbsErr(*,RuinRelErr*)}], LineLegend[Colours,Append[EstNames,RefName]]]*)
(*Export["poisson_pareto_ruin.pdf",RuinPlot];*)



